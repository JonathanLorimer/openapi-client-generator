//! This file is generated by openapi-client-generator.
#![allow(non_camel_case_types)]

use serde_json::json;
use serde::{Serialize, Deserialize};
use httpclient::RequestBuilder;
pub struct PlaidClient {
    client: httpclient::Client,
    authentication: Option<PlaidAuthentication>,
}
impl PlaidClient {
    pub fn new(url: &str) -> Self {
        let client = httpclient::Client::new(Some(url.to_string()));
        let authentication = None;
        Self { client, authentication }
    }
    pub fn with_authentication(mut self, authentication: PlaidAuthentication) -> Self {
        self.authentication = Some(authentication);
        self
    }
    pub fn with_middleware<M: httpclient::Middleware + 'static>(
        mut self,
        middleware: M,
    ) -> Self {
        self.client = self.client.with_middleware(middleware);
        self
    }
    pub async fn item_application_list(
        &self,
        access_token: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "access_token" : access_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn item_application_scopes_update(
        &self,
        access_token: String,
        application_id: String,
        scopes: serde_json::Value,
        state: String,
        context: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "access_token" : access_token, "application_id" :
                        application_id, "scopes" : scopes, "state" : state, "context" :
                        context }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn application_get(
        &self,
        application_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "application_id" : application_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn item_get(
        &self,
        access_token: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "access_token" : access_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn auth_get(
        &self,
        access_token: String,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "access_token" : access_token, "options" : options }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transactions_get(
        &self,
        options: serde_json::Value,
        access_token: String,
        start_date: String,
        end_date: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "options" : options, "access_token" : access_token,
                        "start_date" : start_date, "end_date" : end_date }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transactions_refresh(
        &self,
        access_token: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "access_token" : access_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transactions_recurring_get(
        &self,
        access_token: String,
        account_ids: Vec<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!({ "access_token" : access_token, "account_ids" : account_ids }),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transactions_sync(
        &self,
        access_token: String,
        cursor: String,
        count: i64,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "access_token" : access_token, "cursor" : cursor, "count" :
                        count }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn institutions_get(
        &self,
        count: i64,
        offset: i64,
        country_codes: Vec<CountryCode>,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "count" : count, "offset" : offset, "country_codes" :
                        country_codes, "options" : options }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn institutions_search(
        &self,
        query: String,
        products: Option<Vec<Products>>,
        country_codes: Vec<CountryCode>,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "query" : query, "products" : products, "country_codes" :
                        country_codes, "options" : options }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn institutions_get_by_id(
        &self,
        institution_id: String,
        country_codes: Vec<CountryCode>,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "institution_id" : institution_id, "country_codes" :
                        country_codes, "options" : options }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn item_remove(
        &self,
        access_token: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "access_token" : access_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn accounts_get(
        &self,
        access_token: String,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "access_token" : access_token, "options" : options }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn categories_get(&self) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({}))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn sandbox_processor_token_create(
        &self,
        institution_id: String,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "institution_id" : institution_id, "options" : options }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn sandbox_public_token_create(
        &self,
        institution_id: String,
        initial_products: Vec<Products>,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "institution_id" : institution_id, "initial_products" :
                        initial_products, "options" : options }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn sandbox_item_fire_webhook(
        &self,
        access_token: String,
        webhook_code: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "access_token" : access_token, "webhook_code" : webhook_code }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn accounts_balance_get(
        &self,
        access_token: String,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "access_token" : access_token, "options" : options }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn identity_get(
        &self,
        access_token: String,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "access_token" : access_token, "options" : options }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn processor_auth_get(
        &self,
        processor_token: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "processor_token" : processor_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn processor_bank_transfer_create(
        &self,
        idempotency_key: String,
        processor_token: String,
        typeStruct: String,
        network: String,
        amount: String,
        iso_currency_code: String,
        description: String,
        ach_class: String,
        user: serde_json::Value,
        custom_tag: Option<String>,
        metadata: Option<serde_json::Value>,
        origination_account_id: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "idempotency_key" : idempotency_key, "processor_token" :
                        processor_token, "type" : typeStruct, "network" : network,
                        "amount" : amount, "iso_currency_code" : iso_currency_code,
                        "description" : description, "ach_class" : ach_class, "user" :
                        user, "custom_tag" : custom_tag, "metadata" : metadata,
                        "origination_account_id" : origination_account_id }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn processor_identity_get(
        &self,
        processor_token: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "processor_token" : processor_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn processor_balance_get(
        &self,
        processor_token: String,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!({ "processor_token" : processor_token, "options" : options }),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn item_webhook_update(
        &self,
        access_token: String,
        webhook: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "access_token" : access_token, "webhook" : webhook }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn item_access_token_invalidate(
        &self,
        access_token: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "access_token" : access_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn webhook_verification_key_get(
        &self,
        key_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "key_id" : key_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn liabilities_get(
        &self,
        access_token: String,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "access_token" : access_token, "options" : options }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn payment_initiation_recipient_create(
        &self,
        name: String,
        iban: Option<String>,
        bacs: Option<serde_json::Value>,
        address: Option<serde_json::Value>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "name" : name, "iban" : iban, "bacs" : bacs, "address" :
                        address }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn payment_initiation_payment_reverse(
        &self,
        payment_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "payment_id" : payment_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn payment_initiation_recipient_get(
        &self,
        recipient_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "recipient_id" : recipient_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn payment_initiation_recipient_list(
        &self,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({}))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn payment_initiation_payment_create(
        &self,
        recipient_id: String,
        reference: String,
        amount: serde_json::Value,
        schedule: serde_json::Value,
        options: Option<serde_json::Value>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "recipient_id" : recipient_id, "reference" : reference,
                        "amount" : amount, "schedule" : schedule, "options" : options }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn create_payment_token(
        &self,
        payment_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "payment_id" : payment_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn sandbox_item_reset_login(
        &self,
        access_token: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "access_token" : access_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn sandbox_item_set_verification_status(
        &self,
        access_token: String,
        account_id: String,
        verification_status: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "access_token" : access_token, "account_id" : account_id,
                        "verification_status" : verification_status }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn item_public_token_exchange(
        &self,
        public_token: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "public_token" : public_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn item_create_public_token(
        &self,
        access_token: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "access_token" : access_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn payment_initiation_payment_get(
        &self,
        payment_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "payment_id" : payment_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn payment_initiation_payment_list(
        &self,
        count: Option<i64>,
        cursor: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "count" : count, "cursor" : cursor }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn asset_report_create(
        &self,
        access_tokens: Vec<AccessToken>,
        days_requested: i64,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "access_tokens" : access_tokens, "days_requested" :
                        days_requested, "options" : options }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn asset_report_refresh(
        &self,
        asset_report_token: String,
        days_requested: Option<i64>,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "asset_report_token" : asset_report_token, "days_requested" :
                        days_requested, "options" : options }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn asset_report_remove(
        &self,
        asset_report_token: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "asset_report_token" : asset_report_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn asset_report_filter(
        &self,
        asset_report_token: String,
        account_ids_to_exclude: Vec<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "asset_report_token" : asset_report_token,
                        "account_ids_to_exclude" : account_ids_to_exclude }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn asset_report_get(
        &self,
        asset_report_token: String,
        include_insights: bool,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "asset_report_token" : asset_report_token, "include_insights" :
                        include_insights }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn asset_report_pdf_get(
        &self,
        asset_report_token: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "asset_report_token" : asset_report_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn asset_report_audit_copy_create(
        &self,
        asset_report_token: String,
        auditor_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "asset_report_token" : asset_report_token, "auditor_id" :
                        auditor_id }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn asset_report_audit_copy_remove(
        &self,
        audit_copy_token: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "audit_copy_token" : audit_copy_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn investments_holdings_get(
        &self,
        access_token: String,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "access_token" : access_token, "options" : options }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn investments_transactions_get(
        &self,
        access_token: String,
        start_date: String,
        end_date: String,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "access_token" : access_token, "start_date" : start_date,
                        "end_date" : end_date, "options" : options }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn processor_token_create(
        &self,
        access_token: String,
        account_id: String,
        processor: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "access_token" : access_token, "account_id" : account_id,
                        "processor" : processor }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn processor_stripe_bank_account_token_create(
        &self,
        access_token: String,
        account_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!({ "access_token" : access_token, "account_id" : account_id }),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn processor_apex_processor_token_create(
        &self,
        access_token: String,
        account_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!({ "access_token" : access_token, "account_id" : account_id }),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn deposit_switch_create(
        &self,
        target_access_token: String,
        target_account_id: String,
        country_code: Option<String>,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "target_access_token" : target_access_token,
                        "target_account_id" : target_account_id, "country_code" :
                        country_code, "options" : options }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn item_import(
        &self,
        products: Vec<Products>,
        user_auth: serde_json::Value,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "products" : products, "user_auth" : user_auth, "options" :
                        options }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn deposit_switch_token_create(
        &self,
        deposit_switch_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "deposit_switch_id" : deposit_switch_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn link_token_create(
        &self,
        client_name: String,
        language: String,
        country_codes: Vec<CountryCode>,
        user: serde_json::Value,
        products: Vec<Products>,
        webhook: String,
        access_token: String,
        link_customization_name: String,
        redirect_uri: String,
        android_package_name: String,
        account_filters: serde_json::Value,
        eu_config: serde_json::Value,
        institution_id: String,
        payment_initiation: serde_json::Value,
        deposit_switch: serde_json::Value,
        income_verification: serde_json::Value,
        auth: serde_json::Value,
        transfer: serde_json::Value,
        update: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "client_name" : client_name, "language" : language,
                        "country_codes" : country_codes, "user" : user, "products" :
                        products, "webhook" : webhook, "access_token" : access_token,
                        "link_customization_name" : link_customization_name,
                        "redirect_uri" : redirect_uri, "android_package_name" :
                        android_package_name, "account_filters" : account_filters,
                        "eu_config" : eu_config, "institution_id" : institution_id,
                        "payment_initiation" : payment_initiation, "deposit_switch" :
                        deposit_switch, "income_verification" : income_verification,
                        "auth" : auth, "transfer" : transfer, "update" : update }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn link_token_get(
        &self,
        link_token: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "link_token" : link_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn asset_report_audit_copy_get(
        &self,
        audit_copy_token: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "audit_copy_token" : audit_copy_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn deposit_switch_get(
        &self,
        deposit_switch_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "deposit_switch_id" : deposit_switch_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transfer_get(
        &self,
        transfer_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "transfer_id" : transfer_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn bank_transfer_get(
        &self,
        bank_transfer_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "bank_transfer_id" : bank_transfer_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transfer_authorization_create(
        &self,
        access_token: String,
        account_id: String,
        typeStruct: String,
        network: String,
        amount: String,
        ach_class: String,
        user: serde_json::Value,
        device: serde_json::Value,
        origination_account_id: String,
        iso_currency_code: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "access_token" : access_token, "account_id" : account_id,
                        "type" : typeStruct, "network" : network, "amount" : amount,
                        "ach_class" : ach_class, "user" : user, "device" : device,
                        "origination_account_id" : origination_account_id,
                        "iso_currency_code" : iso_currency_code }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transfer_create(
        &self,
        idempotency_key: String,
        access_token: String,
        account_id: String,
        authorization_id: String,
        typeStruct: String,
        network: String,
        amount: String,
        description: String,
        ach_class: String,
        user: serde_json::Value,
        metadata: Option<serde_json::Value>,
        origination_account_id: Option<String>,
        iso_currency_code: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "idempotency_key" : idempotency_key, "access_token" :
                        access_token, "account_id" : account_id, "authorization_id" :
                        authorization_id, "type" : typeStruct, "network" : network,
                        "amount" : amount, "description" : description, "ach_class" :
                        ach_class, "user" : user, "metadata" : metadata,
                        "origination_account_id" : origination_account_id,
                        "iso_currency_code" : iso_currency_code }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn bank_transfer_create(
        &self,
        idempotency_key: String,
        access_token: String,
        account_id: String,
        typeStruct: String,
        network: String,
        amount: String,
        iso_currency_code: String,
        description: String,
        ach_class: String,
        user: serde_json::Value,
        custom_tag: Option<String>,
        metadata: Option<serde_json::Value>,
        origination_account_id: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "idempotency_key" : idempotency_key, "access_token" :
                        access_token, "account_id" : account_id, "type" : typeStruct,
                        "network" : network, "amount" : amount, "iso_currency_code" :
                        iso_currency_code, "description" : description, "ach_class" :
                        ach_class, "user" : user, "custom_tag" : custom_tag, "metadata" :
                        metadata, "origination_account_id" : origination_account_id }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transfer_list(
        &self,
        start_date: Option<String>,
        end_date: Option<String>,
        count: i64,
        offset: i64,
        origination_account_id: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "start_date" : start_date, "end_date" : end_date, "count" :
                        count, "offset" : offset, "origination_account_id" :
                        origination_account_id }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn bank_transfer_list(
        &self,
        start_date: Option<String>,
        end_date: Option<String>,
        count: i64,
        offset: i64,
        origination_account_id: Option<String>,
        direction: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "start_date" : start_date, "end_date" : end_date, "count" :
                        count, "offset" : offset, "origination_account_id" :
                        origination_account_id, "direction" : direction }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transfer_cancel(
        &self,
        transfer_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "transfer_id" : transfer_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn bank_transfer_cancel(
        &self,
        bank_transfer_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "bank_transfer_id" : bank_transfer_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transfer_event_list(
        &self,
        start_date: Option<String>,
        end_date: Option<String>,
        transfer_id: Option<String>,
        account_id: Option<String>,
        transfer_type: Option<String>,
        event_types: Vec<TransferEventType>,
        sweep_id: String,
        count: Option<i64>,
        offset: Option<i64>,
        origination_account_id: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "start_date" : start_date, "end_date" : end_date, "transfer_id"
                        : transfer_id, "account_id" : account_id, "transfer_type" :
                        transfer_type, "event_types" : event_types, "sweep_id" :
                        sweep_id, "count" : count, "offset" : offset,
                        "origination_account_id" : origination_account_id }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn bank_transfer_event_list(
        &self,
        start_date: Option<String>,
        end_date: Option<String>,
        bank_transfer_id: Option<String>,
        account_id: Option<String>,
        bank_transfer_type: Option<String>,
        event_types: Vec<BankTransferEventType>,
        count: Option<i64>,
        offset: Option<i64>,
        origination_account_id: Option<String>,
        direction: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "start_date" : start_date, "end_date" : end_date,
                        "bank_transfer_id" : bank_transfer_id, "account_id" : account_id,
                        "bank_transfer_type" : bank_transfer_type, "event_types" :
                        event_types, "count" : count, "offset" : offset,
                        "origination_account_id" : origination_account_id, "direction" :
                        direction }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transfer_event_sync(
        &self,
        after_id: i64,
        count: Option<i64>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "after_id" : after_id, "count" : count }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn bank_transfer_event_sync(
        &self,
        after_id: i64,
        count: Option<i64>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "after_id" : after_id, "count" : count }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transfer_sweep_get(
        &self,
        sweep_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "sweep_id" : sweep_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn bank_transfer_sweep_get(
        &self,
        sweep_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "sweep_id" : sweep_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transfer_sweep_list(
        &self,
        start_date: Option<String>,
        end_date: Option<String>,
        count: Option<i64>,
        offset: i64,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "start_date" : start_date, "end_date" : end_date, "count" :
                        count, "offset" : offset }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn bank_transfer_sweep_list(
        &self,
        origination_account_id: Option<String>,
        start_time: Option<String>,
        end_time: Option<String>,
        count: Option<i64>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "origination_account_id" : origination_account_id, "start_time"
                        : start_time, "end_time" : end_time, "count" : count }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn bank_transfer_balance_get(
        &self,
        origination_account_id: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "origination_account_id" : origination_account_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn bank_transfer_migrate_account(
        &self,
        account_number: String,
        routing_number: String,
        account_type: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "account_number" : account_number, "routing_number" :
                        routing_number, "account_type" : account_type }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transfer_intent_create(
        &self,
        account_id: Option<String>,
        mode: String,
        amount: String,
        description: String,
        ach_class: String,
        origination_account_id: Option<String>,
        user: serde_json::Value,
        metadata: Option<serde_json::Value>,
        iso_currency_code: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "account_id" : account_id, "mode" : mode, "amount" : amount,
                        "description" : description, "ach_class" : ach_class,
                        "origination_account_id" : origination_account_id, "user" : user,
                        "metadata" : metadata, "iso_currency_code" : iso_currency_code }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transfer_intent_get(
        &self,
        transfer_intent_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "transfer_intent_id" : transfer_intent_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transfer_repayment_list(
        &self,
        start_date: Option<String>,
        end_date: Option<String>,
        count: Option<i64>,
        offset: i64,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "start_date" : start_date, "end_date" : end_date, "count" :
                        count, "offset" : offset }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn transfer_repayment_return_list(
        &self,
        repayment_id: String,
        count: Option<i64>,
        offset: i64,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "repayment_id" : repayment_id, "count" : count, "offset" :
                        offset }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn sandbox_bank_transfer_simulate(
        &self,
        bank_transfer_id: String,
        event_type: String,
        failure_reason: Option<serde_json::Value>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "bank_transfer_id" : bank_transfer_id, "event_type" :
                        event_type, "failure_reason" : failure_reason }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn sandbox_transfer_sweep_simulate(
        &self,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({}))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn sandbox_transfer_simulate(
        &self,
        transfer_id: String,
        event_type: String,
        failure_reason: Option<serde_json::Value>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "transfer_id" : transfer_id, "event_type" : event_type,
                        "failure_reason" : failure_reason }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn sandbox_transfer_repayment_simulate(
        &self,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({}))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn employers_search(
        &self,
        query: String,
        products: Vec<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "query" : query, "products" : products }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn income_verification_create(
        &self,
        webhook: String,
        precheck_id: String,
        options: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "webhook" : webhook, "precheck_id" : precheck_id, "options" :
                        options }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn income_verification_summary_get(
        &self,
        income_verification_id: Option<String>,
        access_token: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "income_verification_id" : income_verification_id,
                        "access_token" : access_token }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn income_verification_paystub_get(
        &self,
        income_verification_id: Option<String>,
        access_token: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "income_verification_id" : income_verification_id,
                        "access_token" : access_token }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn income_verification_paystubs_get(
        &self,
        income_verification_id: Option<String>,
        access_token: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "income_verification_id" : income_verification_id,
                        "access_token" : access_token }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn income_verification_documents_download(
        &self,
        income_verification_id: Option<String>,
        access_token: Option<String>,
        document_id: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "income_verification_id" : income_verification_id,
                        "access_token" : access_token, "document_id" : document_id }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn income_verification_refresh(
        &self,
        income_verification_id: Option<String>,
        access_token: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "income_verification_id" : income_verification_id,
                        "access_token" : access_token }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn income_verification_taxforms_get(
        &self,
        income_verification_id: Option<String>,
        access_token: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "income_verification_id" : income_verification_id,
                        "access_token" : access_token }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn income_verification_precheck(
        &self,
        user: Option<serde_json::Value>,
        employer: Option<serde_json::Value>,
        transactions_access_token: serde_json::Value,
        transactions_access_tokens: Vec<AccessToken>,
        us_military_info: Option<serde_json::Value>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "user" : user, "employer" : employer,
                        "transactions_access_token" : transactions_access_token,
                        "transactions_access_tokens" : transactions_access_tokens,
                        "us_military_info" : us_military_info }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn employment_verification_get(
        &self,
        access_token: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "access_token" : access_token }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn deposit_switch_alt_create(
        &self,
        target_account: serde_json::Value,
        target_user: serde_json::Value,
        options: serde_json::Value,
        country_code: Option<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "target_account" : target_account, "target_user" : target_user,
                        "options" : options, "country_code" : country_code }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn sandbox_bank_transfer_fire_webhook(
        &self,
        webhook: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "webhook" : webhook }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn sandbox_income_fire_webhook(
        &self,
        income_verification_id: String,
        item_id: String,
        webhook: String,
        verification_status: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "income_verification_id" : income_verification_id, "item_id" :
                        item_id, "webhook" : webhook, "verification_status" :
                        verification_status }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn sandbox_oauth_select_accounts(
        &self,
        oauth_state_id: String,
        accounts: Vec<String>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!({ "oauth_state_id" : oauth_state_id, "accounts" : accounts }),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn signal_evaluate(
        &self,
        access_token: String,
        account_id: String,
        client_transaction_id: String,
        amount: f64,
        user_present: Option<bool>,
        client_user_id: String,
        user: serde_json::Value,
        device: serde_json::Value,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "access_token" : access_token, "account_id" : account_id,
                        "client_transaction_id" : client_transaction_id, "amount" :
                        amount, "user_present" : user_present, "client_user_id" :
                        client_user_id, "user" : user, "device" : device }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn signal_decision_report(
        &self,
        client_transaction_id: String,
        initiated: bool,
        days_funds_on_hold: Option<i64>,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "client_transaction_id" : client_transaction_id, "initiated" :
                        initiated, "days_funds_on_hold" : days_funds_on_hold }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn signal_return_report(
        &self,
        client_transaction_id: String,
        return_code: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "client_transaction_id" : client_transaction_id, "return_code"
                        : return_code }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn wallet_get(
        &self,
        wallet_id: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(json!({ "wallet_id" : wallet_id }))
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn wallet_transaction_execute(
        &self,
        idempotency_key: String,
        wallet_id: String,
        counterparty: serde_json::Value,
        amount: serde_json::Value,
        reference: String,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "idempotency_key" : idempotency_key, "wallet_id" : wallet_id,
                        "counterparty" : counterparty, "amount" : amount, "reference" :
                        reference }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
    pub async fn wallet_transactions_list(
        &self,
        wallet_id: String,
        cursor: String,
        count: i64,
    ) -> anyhow::Result<ItemGetResponse> {
        {
            let res = self
                .client
                .post("/item/get")
                .json(
                    json!(
                        { "wallet_id" : wallet_id, "cursor" : cursor, "count" : count }
                    ),
                )
                .authenticate(&self.authentication)
                .send()
                .await
                .unwrap()
                .error_for_status();
            match res {
                Ok(res) => res.json().await.map_err(|e| anyhow::anyhow!("{:?}", e)),
                Err(res) => {
                    let text = res.text().await.map_err(|e| anyhow::anyhow!("{:?}", e));
                    Err(anyhow::anyhow!("{:?}", text))
                }
            }
        }
    }
}
pub enum PlaidAuthentication {
    ClientId { client_id: String, secret: String, plaid_version: String },
}
impl PlaidAuthentication {
    pub fn from_env() -> Self {
        Self::ClientId {
            client_id: std::env::var("PLAID_CLIENT_ID")
                .expect("Environment variable PLAID_CLIENT_ID not set"),
            secret: std::env::var("PLAID_SECRET")
                .expect("Environment variable PLAID_SECRET not set"),
            plaid_version: std::env::var("PLAID_VERSION")
                .expect("Environment variable PLAID_VERSION not set"),
        }
    }
}
trait Authenticatable {
    fn authenticate(self, authenticator: &Option<PlaidAuthentication>) -> Self;
}
impl<'a> Authenticatable for RequestBuilder<'a> {
    fn authenticate(self, authenticator: &Option<PlaidAuthentication>) -> Self {
        if let Some(authenticator) = authenticator {
            match authenticator {
                PlaidAuthentication::ClientId { client_id, secret, .. } => {
                    self
                        .push_json(
                            json!({ "client_id" : client_id, "secret" : secret, }),
                        )
                }
            }
        } else {
            self
        }
    }
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemGetResponse {
    pub item: Item,
    pub status: ItemStatusNullable,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AuthGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
    pub options: Option<AuthGetRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AuthGetRequestOptions {
    pub account_ids: Option<Vec<String>>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AuthGetResponse {
    pub accounts: Vec<AccountBase>,
    pub numbers: AuthGetNumbers,
    pub item: Item,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AuthGetNumbers {
    pub ach: Vec<NumbersACH>,
    pub eft: Vec<NumbersEFT>,
    pub international: Vec<NumbersInternational>,
    pub bacs: Vec<NumbersBACS>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionsGetRequest {
    pub client_id: Option<APIClientID>,
    pub options: Option<TransactionsGetRequestOptions>,
    pub access_token: AccessToken,
    pub secret: Option<APISecret>,
    pub start_date: String,
    pub end_date: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionsGetRequestOptions {
    pub account_ids: Option<Vec<String>>,
    pub count: Option<i64>,
    pub offset: Option<i64>,
    pub include_original_description: Option<bool>,
    pub include_personal_finance_category_beta: Option<bool>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionsGetResponse {
    pub accounts: Vec<AccountBase>,
    pub transactions: Vec<Transaction>,
    pub total_transactions: i64,
    pub item: Item,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionsRefreshRequest {
    pub client_id: Option<APIClientID>,
    pub access_token: AccessToken,
    pub secret: Option<APISecret>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionsRefreshResponse {
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionsRecurringGetRequest {
    pub client_id: Option<APIClientID>,
    pub access_token: AccessToken,
    pub secret: Option<APISecret>,
    pub account_ids: Vec<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionsRecurringGetResponse {
    pub inflow_streams: Vec<TransactionStream>,
    pub outflow_streams: Vec<TransactionStream>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionsSyncRequest {
    pub client_id: Option<APIClientID>,
    pub access_token: AccessToken,
    pub secret: Option<APISecret>,
    pub cursor: Option<String>,
    pub count: Option<i64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionsSyncResponse {
    pub added: Vec<Transaction>,
    pub modified: Vec<Transaction>,
    pub removed: Vec<RemovedTransaction>,
    pub next_cursor: String,
    pub has_more: bool,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InstitutionsGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub count: i64,
    pub offset: i64,
    pub country_codes: Vec<CountryCode>,
    pub options: Option<InstitutionsGetRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InstitutionsGetRequestOptions {
    pub products: Option<Vec<Products>>,
    pub routing_numbers: Option<Vec<String>>,
    pub oauth: Option<bool>,
    pub include_optional_metadata: Option<bool>,
    pub include_auth_metadata: Option<bool>,
    pub include_payment_initiation_metadata: Option<bool>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InstitutionsGetResponse {
    pub institutions: Vec<Institution>,
    pub total: i64,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InstitutionsSearchRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub query: String,
    pub products: Option<Vec<Products>>,
    pub country_codes: Vec<CountryCode>,
    pub options: Option<InstitutionsSearchRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InstitutionsSearchRequestOptions {
    pub oauth: Option<bool>,
    pub include_optional_metadata: Option<bool>,
    pub include_auth_metadata: Option<bool>,
    pub include_payment_initiation_metadata: Option<bool>,
    pub payment_initiation: InstitutionsSearchPaymentInitiationOptions,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InstitutionsSearchPaymentInitiationOptions {
    pub payment_id: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InstitutionsSearchResponse {
    pub institutions: Vec<Institution>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InstitutionsGetByIdRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub institution_id: String,
    pub country_codes: Vec<CountryCode>,
    pub options: Option<InstitutionsGetByIdRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InstitutionsGetByIdRequestOptions {
    pub include_optional_metadata: Option<bool>,
    pub include_status: Option<bool>,
    pub include_auth_metadata: Option<bool>,
    pub include_payment_initiation_metadata: Option<bool>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InstitutionsGetByIdResponse {
    pub institution: Institution,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemRemoveRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemRemoveResponse {
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountsGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
    pub options: Option<AccountsGetRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountsGetRequestOptions {
    pub account_ids: Option<Vec<String>>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountsGetResponse {
    pub accounts: Vec<AccountBase>,
    pub item: Item,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct CategoriesGetRequest {}
#[derive(Debug, Serialize, Deserialize)]
pub struct CategoriesGetResponse {
    pub categories: Vec<Category>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxOverridePassword(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxOverrideUsername(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxProcessorTokenCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub institution_id: String,
    pub options: Option<SandboxProcessorTokenCreateRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxProcessorTokenCreateRequestOptions {
    pub override_username: SandboxOverrideUsername,
    pub override_password: SandboxOverridePassword,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxProcessorTokenCreateResponse {
    pub processor_token: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxPublicTokenCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub institution_id: String,
    pub initial_products: Vec<Products>,
    pub options: Option<SandboxPublicTokenCreateRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxPublicTokenCreateRequestOptions {
    pub webhook: Option<String>,
    pub override_username: SandboxOverrideUsername,
    pub override_password: SandboxOverridePassword,
    pub transactions: Option<SandboxPublicTokenCreateRequestOptionsTransactions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxPublicTokenCreateRequestOptionsTransactions {
    pub start_date: Option<String>,
    pub end_date: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxPublicTokenCreateResponse {
    pub public_token: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxItemFireWebhookRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
    pub webhook_code: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxItemFireWebhookResponse {
    pub webhook_fired: bool,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountsBalanceGetRequest {
    pub access_token: AccessToken,
    pub secret: Option<APISecret>,
    pub client_id: Option<APIClientID>,
    pub options: Option<AccountsBalanceGetRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountsBalanceGetRequestOptions {
    pub account_ids: Option<Vec<String>>,
    pub min_last_updated_datetime: Option<MinLastUpdatedDatetime>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct MinLastUpdatedDatetime(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct IdentityGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
    pub options: Option<IdentityGetRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IdentityGetRequestOptions {
    pub account_ids: Option<Vec<String>>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IdentityGetResponse {
    pub accounts: Vec<AccountIdentity>,
    pub item: Item,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorAuthGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub processor_token: ProcessorToken,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorAuthGetResponse {
    pub request_id: RequestID,
    pub numbers: ProcessorNumber,
    pub account: AccountBase,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorBankTransferCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub idempotency_key: BankTransferIdempotencyKey,
    pub processor_token: ProcessorToken,
    #[serde(rename = "type")]
    pub type_: BankTransferType,
    pub network: BankTransferNetwork,
    pub amount: BankTransferAmount,
    pub iso_currency_code: String,
    pub description: String,
    pub ach_class: Option<ACHClass>,
    pub user: BankTransferUser,
    pub custom_tag: Option<String>,
    pub metadata: BankTransferMetadata,
    pub origination_account_id: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorBankTransferCreateResponse {
    pub bank_transfer: BankTransfer,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorNumber {
    pub ach: NumbersACHNullable,
    pub eft: NumbersEFTNullable,
    pub international: NumbersInternationalNullable,
    pub bacs: NumbersBACSNullable,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorIdentityGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub processor_token: ProcessorToken,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorIdentityGetResponse {
    pub account: AccountIdentity,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorBalanceGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub processor_token: ProcessorToken,
    pub options: Option<ProcessorBalanceGetRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorBalanceGetRequestOptions {
    pub min_last_updated_datetime: Option<MinLastUpdatedDatetime>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorBalanceGetResponse {
    pub account: AccountBase,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemWebhookUpdateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
    pub webhook: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemWebhookUpdateResponse {
    pub item: Item,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemAccessTokenInvalidateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemAccessTokenInvalidateResponse {
    pub new_access_token: AccessToken,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct WebhookVerificationKeyGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub key_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct WebhookVerificationKeyGetResponse {
    pub key: JWKPublicKey,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct JWKPublicKey {
    pub alg: String,
    pub crv: String,
    pub kid: String,
    pub kty: String,
    #[serde(rename = "use")]
    pub use_: String,
    pub x: String,
    pub y: String,
    pub created_at: i64,
    pub expired_at: Option<i64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LiabilitiesGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
    pub options: Option<LiabilitiesGetRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LiabilitiesGetRequestOptions {
    pub account_ids: Option<Vec<String>>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LiabilitiesGetResponse {
    pub accounts: Vec<AccountBase>,
    pub item: Item,
    pub liabilities: LiabilitiesObject,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationRecipientCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub name: String,
    pub iban: Option<String>,
    pub bacs: RecipientBACSNullable,
    pub address: PaymentInitiationAddress,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationRecipientCreateResponse {
    pub recipient_id: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationPaymentReverseResponse {
    pub refund_id: String,
    pub status: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationRecipientGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub recipient_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationRecipientGetResponse(pub serde_json::Value);
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationRecipient {
    pub recipient_id: String,
    pub name: String,
    pub address: PaymentInitiationAddress,
    pub iban: Option<String>,
    pub bacs: RecipientBACSNullable,
    pub emi_recipient_id: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationRecipientListRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationRecipientListResponse {
    pub recipients: Vec<PaymentInitiationRecipient>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationPaymentCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub recipient_id: String,
    pub reference: String,
    pub amount: PaymentAmount,
    pub schedule: Option<ExternalPaymentScheduleRequest>,
    pub options: ExternalPaymentOptions,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationPaymentReverseRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub payment_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationPaymentCreateResponse {
    pub payment_id: String,
    pub status: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxItemResetLoginRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxItemResetLoginResponse {
    pub reset_login: bool,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxItemSetVerificationStatusRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
    pub account_id: String,
    pub verification_status: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxItemSetVerificationStatusResponse {
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemPublicTokenExchangeRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub public_token: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemPublicTokenExchangeResponse {
    pub access_token: AccessToken,
    pub item_id: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemPublicTokenCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemPublicTokenCreateResponse {
    pub public_token: String,
    pub expiration: Option<String>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationPaymentGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub payment_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationPaymentGetResponse(pub serde_json::Value);
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationPaymentStatus(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationPayment {
    pub payment_id: String,
    pub amount: PaymentAmount,
    pub status: PaymentInitiationPaymentStatus,
    pub recipient_id: String,
    pub reference: String,
    pub adjusted_reference: Option<String>,
    pub last_status_update: String,
    pub schedule: ExternalPaymentScheduleGet,
    pub refund_details: ExternalPaymentRefundDetails,
    pub bacs: SenderBACSNullable,
    pub iban: Option<String>,
    pub initiated_refunds: Option<Vec<PaymentInitiationRefund>>,
    pub wallet_id: Option<String>,
    pub scheme: PaymentScheme,
    pub adjusted_scheme: PaymentScheme,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationRefund {
    pub refund_id: String,
    pub amount: PaymentAmount,
    pub status: String,
    pub last_status_update: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationPaymentTokenCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub payment_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationPaymentTokenCreateResponse {
    pub payment_token: String,
    pub payment_token_expiration_time: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationPaymentListRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub count: Option<i64>,
    pub cursor: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationPaymentListResponse {
    pub payments: Vec<PaymentInitiationPayment>,
    pub next_cursor: Option<String>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_tokens: Vec<AccessToken>,
    pub days_requested: i64,
    pub options: Option<AssetReportCreateRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportCreateRequestOptions {
    pub client_report_id: Option<String>,
    pub webhook: Option<String>,
    pub user: Option<AssetReportUser>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportCreateResponse {
    pub asset_report_token: AssetReportToken,
    pub asset_report_id: AssetReportId,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportRefreshRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub asset_report_token: AssetReportRefreshAssetReportToken,
    pub days_requested: Option<i64>,
    pub options: Option<AssetReportRefreshRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportRefreshRequestOptions {
    pub client_report_id: Option<String>,
    pub webhook: Option<String>,
    pub user: Option<AssetReportUser>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportRefreshResponse {
    pub asset_report_id: AssetReportId,
    pub asset_report_token: AssetReportToken,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportRemoveRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub asset_report_token: AssetReportToken,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportRemoveResponse {
    pub removed: bool,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportFilterRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub asset_report_token: AssetReportToken,
    pub account_ids_to_exclude: Vec<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportFilterResponse {
    pub asset_report_token: AssetReportToken,
    pub asset_report_id: AssetReportId,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub asset_report_token: AssetReportToken,
    pub include_insights: Option<bool>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportGetResponse {
    pub report: AssetReport,
    pub warnings: Vec<Warning>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportPDFGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub asset_report_token: AssetReportToken,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportPDFGetResponse(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportAuditCopyCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub asset_report_token: AssetReportToken,
    pub auditor_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportAuditCopyCreateResponse {
    pub audit_copy_token: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportAuditCopyRemoveRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub audit_copy_token: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportAuditCopyRemoveResponse {
    pub removed: bool,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InvestmentsHoldingsGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
    pub options: Option<InvestmentHoldingsGetRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InvestmentHoldingsGetRequestOptions {
    pub account_ids: Option<Vec<String>>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InvestmentsHoldingsGetResponse {
    pub accounts: Vec<AccountBase>,
    pub holdings: Vec<Holding>,
    pub securities: Vec<Security>,
    pub item: Item,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InvestmentsTransactionsGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
    pub start_date: String,
    pub end_date: String,
    pub options: Option<InvestmentsTransactionsGetRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InvestmentsTransactionsGetRequestOptions {
    pub account_ids: Option<Vec<String>>,
    pub count: Option<i64>,
    pub offset: Option<i64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InvestmentsTransactionsGetResponse {
    pub item: Item,
    pub accounts: Vec<AccountBase>,
    pub securities: Vec<Security>,
    pub investment_transactions: Vec<InvestmentTransaction>,
    pub total_investment_transactions: i64,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorTokenCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
    pub account_id: String,
    pub processor: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorTokenCreateResponse {
    pub processor_token: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorStripeBankAccountTokenCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
    pub account_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorStripeBankAccountTokenCreateResponse {
    pub stripe_bank_account_token: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorApexProcessorTokenCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
    pub account_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositSwitchCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub target_access_token: String,
    pub target_account_id: String,
    pub country_code: Option<String>,
    pub options: Option<DepositSwitchCreateRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositSwitchCreateRequestOptions {
    pub webhook: Option<String>,
    pub transaction_item_access_tokens: Option<Vec<AccessToken>>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositSwitchCreateResponse {
    pub deposit_switch_id: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemImportRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub products: Vec<Products>,
    pub user_auth: ItemImportRequestUserAuth,
    pub options: Option<ItemImportRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemImportRequestOptions {
    pub webhook: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemImportRequestUserAuth {
    pub user_id: String,
    pub auth_token: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemImportResponse {
    pub access_token: AccessToken,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositSwitchTokenCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub deposit_switch_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositSwitchTokenCreateResponse {
    pub deposit_switch_token: String,
    pub deposit_switch_token_expiration_time: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub link_token: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub client_name: String,
    pub language: String,
    pub country_codes: Vec<CountryCode>,
    pub user: LinkTokenCreateRequestUser,
    pub products: Option<Vec<Products>>,
    pub webhook: Option<String>,
    pub access_token: Option<String>,
    pub link_customization_name: Option<String>,
    pub redirect_uri: Option<String>,
    pub android_package_name: Option<String>,
    pub account_filters: Option<LinkTokenAccountFilters>,
    pub eu_config: Option<LinkTokenEUConfig>,
    pub institution_id: Option<String>,
    pub payment_initiation: Option<LinkTokenCreateRequestPaymentInitiation>,
    pub deposit_switch: Option<LinkTokenCreateRequestDepositSwitch>,
    pub income_verification: Option<LinkTokenCreateRequestIncomeVerification>,
    pub auth: Option<LinkTokenCreateRequestAuth>,
    pub transfer: Option<LinkTokenCreateRequestTransfer>,
    pub update: Option<LinkTokenCreateRequestUpdate>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenAccountFilters {
    pub depository: Option<DepositoryFilter>,
    pub credit: Option<CreditFilter>,
    pub loan: Option<LoanFilter>,
    pub investment: Option<InvestmentFilter>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenEUConfig {
    pub headless: Option<bool>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenCreateRequestPaymentInitiation {
    pub payment_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenCreateRequestDepositSwitch {
    pub deposit_switch_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenCreateRequestTransfer {
    pub intent_id: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenCreateRequestAuth {
    pub flow_type: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenCreateRequestUser {
    pub client_user_id: String,
    pub legal_name: Option<String>,
    pub phone_number: Option<String>,
    pub phone_number_verified_time: Option<String>,
    pub email_address: Option<String>,
    pub email_address_verified_time: Option<String>,
    pub ssn: Option<String>,
    pub date_of_birth: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenCreateRequestUpdate {
    pub account_selection_enabled: Option<bool>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenCreateRequestAccountSubtypes {
    pub depository: Option<LinkTokenCreateDepositoryFilter>,
    pub credit: Option<LinkTokenCreateCreditFilter>,
    pub loan: Option<LinkTokenCreateLoanFilter>,
    pub investment: Option<LinkTokenCreateInvestmentFilter>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenCreateDepositoryFilter {
    pub account_subtypes: Option<DepositoryAccountSubtypes>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenCreateCreditFilter {
    pub account_subtypes: Option<CreditAccountSubtypes>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenCreateLoanFilter {
    pub account_subtypes: Option<LoanAccountSubtypes>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenCreateInvestmentFilter {
    pub account_subtypes: Option<InvestmentAccountSubtypes>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenGetResponse {
    pub link_token: String,
    pub created_at: Option<String>,
    pub expiration: Option<String>,
    pub metadata: LinkTokenGetMetadataResponse,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenGetMetadataResponse {
    pub initial_products: Vec<Products>,
    pub webhook: Option<String>,
    pub country_codes: Vec<CountryCode>,
    pub language: Option<String>,
    pub account_filters: Option<AccountFiltersResponse>,
    pub redirect_uri: Option<String>,
    pub client_name: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenCreateResponse {
    pub link_token: String,
    pub expiration: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Item {
    pub item_id: String,
    pub institution_id: Option<String>,
    pub webhook: Option<String>,
    pub error: Error,
    pub available_products: Vec<Products>,
    pub billed_products: Vec<Products>,
    pub products: Option<Vec<Products>>,
    pub consent_expiration_time: Option<String>,
    pub update_type: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PlaidError(pub serde_json::Value);
#[derive(Debug, Serialize, Deserialize)]
pub struct Error {
    pub error_type: String,
    pub error_code: String,
    pub error_message: String,
    pub display_message: Option<String>,
    pub request_id: Option<String>,
    pub causes: Option<Vec<serde_json::Value>>,
    pub status: Option<f64>,
    pub documentation_url: Option<String>,
    pub suggested_action: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemStatusNullable(pub Option<serde_json::Value>);
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemStatusTransactions {
    pub last_successful_update: Option<String>,
    pub last_failed_update: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemStatusInvestments {
    pub last_successful_update: Option<String>,
    pub last_failed_update: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemStatusLastWebhook {
    pub sent_at: Option<String>,
    pub code_sent: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemStatus {
    pub investments: ItemStatusInvestments,
    pub transactions: ItemStatusTransactions,
    pub last_webhook: ItemStatusLastWebhook,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountType(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct OverrideAccountType(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountBase {
    pub account_id: String,
    pub balances: AccountBalance,
    pub mask: Option<String>,
    pub name: String,
    pub official_name: Option<String>,
    #[serde(rename = "type")]
    pub type_: AccountType,
    pub subtype: AccountSubtype,
    pub verification_status: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountBalance {
    pub available: Option<f64>,
    pub current: Option<f64>,
    pub limit: Option<f64>,
    pub iso_currency_code: Option<String>,
    pub unofficial_currency_code: Option<String>,
    pub last_updated_datetime: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountSubtype(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct NumbersACH {
    pub account_id: String,
    pub account: String,
    pub routing: String,
    pub wire_routing: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct NumbersACHNullable(pub Option<serde_json::Value>);
#[derive(Debug, Serialize, Deserialize)]
pub struct NumbersEFT {
    pub account_id: String,
    pub account: String,
    pub institution: String,
    pub branch: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct NumbersEFTNullable(pub Option<serde_json::Value>);
#[derive(Debug, Serialize, Deserialize)]
pub struct NumbersInternational {
    pub account_id: String,
    pub iban: String,
    pub bic: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct NumbersInternationalNullable(pub Option<serde_json::Value>);
#[derive(Debug, Serialize, Deserialize)]
pub struct NumbersBACS {
    pub account_id: String,
    pub account: String,
    pub sort_code: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct NumbersBACSNullable(pub Option<serde_json::Value>);
#[derive(Debug, Serialize, Deserialize)]
pub struct RecipientBACS {
    pub account: Option<String>,
    pub sort_code: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct RecipientBACSNullable(pub Option<serde_json::Value>);
#[derive(Debug, Serialize, Deserialize)]
pub struct SenderBACSNullable(pub Option<serde_json::Value>);
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationOptionalRestrictionBacs(pub Option<serde_json::Value>);
#[derive(Debug, Serialize, Deserialize)]
pub struct RemovedTransaction {
    pub transaction_id: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct RequestID(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionBase {
    pub transaction_type: Option<String>,
    pub pending_transaction_id: Option<String>,
    pub category_id: Option<String>,
    pub category: Option<Vec<String>>,
    pub location: Option<Location>,
    pub payment_meta: Option<PaymentMeta>,
    pub account_owner: Option<String>,
    pub name: Option<String>,
    pub original_description: Option<String>,
    pub account_id: String,
    pub amount: f64,
    pub iso_currency_code: Option<String>,
    pub unofficial_currency_code: Option<String>,
    pub date: String,
    pub pending: bool,
    pub transaction_id: String,
    pub merchant_name: Option<String>,
    pub check_number: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Transaction(pub serde_json::Value);
#[derive(Debug, Serialize, Deserialize)]
pub struct Location {
    pub address: Option<String>,
    pub city: Option<String>,
    pub region: Option<String>,
    pub postal_code: Option<String>,
    pub country: Option<String>,
    pub lat: Option<f64>,
    pub lon: Option<f64>,
    pub store_number: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionStream {
    pub account_id: String,
    pub stream_id: String,
    pub category_id: String,
    pub category: Vec<String>,
    pub description: String,
    pub first_date: String,
    pub last_date: String,
    pub frequency: RecurringTransactionFrequency,
    pub transaction_ids: Vec<String>,
    pub average_amount: TransactionStreamAmount,
    pub is_active: bool,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionStreamAmount {
    pub amount: Option<f64>,
    pub iso_currency_code: Option<String>,
    pub unofficial_currency_code: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct RecurringTransactionFrequency(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct Institution {
    pub institution_id: String,
    pub name: String,
    pub products: Vec<Products>,
    pub country_codes: Vec<CountryCode>,
    pub url: Option<String>,
    pub primary_color: Option<String>,
    pub logo: Option<String>,
    pub routing_numbers: Vec<String>,
    pub oauth: bool,
    pub status: InstitutionStatus,
    pub payment_initiation_metadata: PaymentInitiationMetadata,
    pub auth_metadata: AuthMetadata,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InstitutionStatus {
    pub item_logins: ProductStatus,
    pub transactions_updates: ProductStatus,
    pub auth: ProductStatus,
    pub identity: ProductStatus,
    pub investments_updates: ProductStatus,
    pub liabilities_updates: Option<ProductStatus>,
    pub liabilities: Option<ProductStatus>,
    pub investments: Option<ProductStatus>,
    pub health_incidents: Option<Vec<HealthIncident>>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct CountryCode(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentMeta {
    pub reference_number: Option<String>,
    pub ppd_id: Option<String>,
    pub payee: Option<String>,
    pub by_order_of: Option<String>,
    pub payer: Option<String>,
    pub payment_method: Option<String>,
    pub payment_processor: Option<String>,
    pub reason: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionCode(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct Category {
    pub category_id: String,
    pub group: String,
    pub hierarchy: Vec<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PersonalFinanceCategory {
    pub primary: String,
    pub detailed: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AccessToken(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct AccessTokenNullable(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferAccessToken(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferAccessToken(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct APISecret(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct APIClientID(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionsRemovedWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub error: Option<PlaidError>,
    pub removed_transactions: Vec<String>,
    pub item_id: ItemId,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DefaultUpdateWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub error: Option<PlaidError>,
    pub new_transactions: f64,
    pub item_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct HistoricalUpdateWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub error: Option<PlaidError>,
    pub new_transactions: f64,
    pub item_id: ItemId,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InitialUpdateWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub error: Option<String>,
    pub new_transactions: f64,
    pub item_id: ItemId,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PhoneNumber {
    pub data: String,
    pub primary: bool,
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Email {
    pub data: String,
    pub primary: bool,
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Address {
    pub data: AddressData,
    pub primary: Option<bool>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AddressNullable(pub Option<serde_json::Value>);
#[derive(Debug, Serialize, Deserialize)]
pub struct AddressDataNullable(pub Option<serde_json::Value>);
#[derive(Debug, Serialize, Deserialize)]
pub struct AddressData {
    pub city: String,
    pub region: Option<String>,
    pub street: String,
    pub postal_code: Option<String>,
    pub country: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessorToken(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct HistoricalBalance {
    pub date: String,
    pub current: f64,
    pub iso_currency_code: Option<String>,
    pub unofficial_currency_code: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Owner {
    pub names: Vec<String>,
    pub phone_numbers: Vec<PhoneNumber>,
    pub emails: Vec<Email>,
    pub addresses: Vec<Address>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct OwnerOverride {
    pub names: Vec<String>,
    pub phone_numbers: Vec<PhoneNumber>,
    pub emails: Vec<Email>,
    pub addresses: Vec<Address>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LiabilitiesObject {
    pub credit: Option<Vec<CreditCardLiability>>,
    pub mortgage: Option<Vec<MortgageLiability>>,
    pub student: Option<Vec<StudentLoan>>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct StudentLoan {
    pub account_id: Option<String>,
    pub account_number: Option<String>,
    pub disbursement_dates: Option<Vec<String>>,
    pub expected_payoff_date: Option<String>,
    pub guarantor: Option<String>,
    pub interest_rate_percentage: f64,
    pub is_overdue: Option<bool>,
    pub last_payment_amount: Option<f64>,
    pub last_payment_date: Option<String>,
    pub last_statement_issue_date: Option<String>,
    pub loan_name: Option<String>,
    pub loan_status: StudentLoanStatus,
    pub minimum_payment_amount: Option<f64>,
    pub next_payment_due_date: Option<String>,
    pub origination_date: Option<String>,
    pub origination_principal_amount: Option<f64>,
    pub outstanding_interest_amount: Option<f64>,
    pub payment_reference_number: Option<String>,
    pub pslf_status: PSLFStatus,
    pub repayment_plan: StudentRepaymentPlan,
    pub sequence_number: Option<String>,
    pub servicer_address: ServicerAddressData,
    pub ytd_interest_paid: Option<f64>,
    pub ytd_principal_paid: Option<f64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct CreditCardLiability {
    pub account_id: Option<String>,
    pub aprs: Vec<APR>,
    pub is_overdue: Option<bool>,
    pub last_payment_amount: f64,
    pub last_payment_date: Option<String>,
    pub last_statement_issue_date: String,
    pub last_statement_balance: f64,
    pub minimum_payment_amount: f64,
    pub next_payment_due_date: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct MortgageLiability {
    pub account_id: String,
    pub account_number: String,
    pub current_late_fee: Option<f64>,
    pub escrow_balance: Option<f64>,
    pub has_pmi: Option<bool>,
    pub has_prepayment_penalty: Option<bool>,
    pub interest_rate: MortgageInterestRate,
    pub last_payment_amount: Option<f64>,
    pub last_payment_date: Option<String>,
    pub loan_type_description: Option<String>,
    pub loan_term: Option<String>,
    pub maturity_date: Option<String>,
    pub next_monthly_payment: Option<f64>,
    pub next_payment_due_date: Option<String>,
    pub origination_date: Option<String>,
    pub origination_principal_amount: Option<f64>,
    pub past_due_amount: Option<f64>,
    pub property_address: MortgagePropertyAddress,
    pub ytd_interest_paid: Option<f64>,
    pub ytd_principal_paid: Option<f64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct MortgageInterestRate {
    pub percentage: Option<f64>,
    #[serde(rename = "type")]
    pub type_: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct MortgagePropertyAddress {
    pub city: Option<String>,
    pub country: Option<String>,
    pub postal_code: Option<String>,
    pub region: Option<String>,
    pub street: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct StudentLoanStatus {
    pub end_date: Option<String>,
    #[serde(rename = "type")]
    pub type_: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct StudentRepaymentPlan {
    pub description: Option<String>,
    #[serde(rename = "type")]
    pub type_: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PSLFStatus {
    pub estimated_eligibility_date: Option<String>,
    pub payments_made: Option<f64>,
    pub payments_remaining: Option<f64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ServicerAddressData {
    pub city: Option<String>,
    pub region: Option<String>,
    pub street: Option<String>,
    pub postal_code: Option<String>,
    pub country: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct APR {
    pub apr_percentage: f64,
    pub apr_type: String,
    pub balance_subject_to_apr: Option<f64>,
    pub interest_charge_amount: Option<f64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AuthMetadata {
    pub supported_methods: AuthSupportedMethods,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AuthSupportedMethods {
    pub instant_auth: bool,
    pub instant_match: bool,
    pub automated_micro_deposits: bool,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationMetadata {
    pub supports_international_payments: bool,
    pub maximum_payment_amount: PaymentInitiationMaximumPaymentAmount,
    pub supports_refund_details: bool,
    pub standing_order_metadata: PaymentInitiationStandingOrderMetadata,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationMaximumPaymentAmount {}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationStandingOrderMetadata {
    pub supports_standing_order_end_date: bool,
    pub supports_standing_order_negative_execution_days: bool,
    pub valid_standing_order_intervals: Vec<PaymentScheduleInterval>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentInitiationAddress {
    pub street: Vec<String>,
    pub city: String,
    pub postal_code: String,
    pub country: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ExternalPaymentScheduleBase {
    pub interval: Option<PaymentScheduleInterval>,
    pub interval_execution_day: Option<i64>,
    pub start_date: Option<String>,
    pub end_date: Option<String>,
    pub adjusted_start_date: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ExternalPaymentScheduleRequest(pub serde_json::Value);
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentScheduleInterval(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentScheme(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct ExternalPaymentOptions {
    pub request_refund_details: Option<bool>,
    pub iban: Option<String>,
    pub bacs: PaymentInitiationOptionalRestrictionBacs,
    pub wallet_id: Option<String>,
    pub scheme: PaymentScheme,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ExternalPaymentRefundDetails {
    pub name: String,
    pub iban: Option<String>,
    pub bacs: RecipientBACSNullable,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ExternalPaymentScheduleGet(pub Option<serde_json::Value>);
#[derive(Debug, Serialize, Deserialize)]
pub struct Products(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct ProductStatus {
    pub status: String,
    pub last_status_change: String,
    pub breakdown: ProductStatusBreakdown,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProductStatusBreakdown {
    pub success: f64,
    pub error_plaid: f64,
    pub error_institution: f64,
    pub refresh_interval: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct UserCustomPassword {
    pub version: Option<String>,
    pub seed: String,
    pub override_accounts: Vec<OverrideAccounts>,
    pub mfa: MFA,
    pub recaptcha: String,
    pub force_error: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct MFA {
    #[serde(rename = "type")]
    pub type_: String,
    pub question_rounds: f64,
    pub questions_per_round: f64,
    pub selection_rounds: f64,
    pub selections_per_question: f64,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct OverrideAccounts {
    #[serde(rename = "type")]
    pub type_: OverrideAccountType,
    pub subtype: AccountSubtype,
    pub starting_balance: f64,
    pub force_available_balance: f64,
    pub currency: String,
    pub meta: Meta,
    pub numbers: Numbers,
    pub transactions: Vec<TransactionOverride>,
    pub holdings: Option<HoldingsOverride>,
    pub investment_transactions: Option<Investments_TransactionsOverride>,
    pub identity: OwnerOverride,
    pub liability: LiabilityOverride,
    pub inflow_model: InflowModel,
    pub income: Option<IncomeOverride>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Meta {
    pub name: String,
    pub official_name: String,
    pub limit: f64,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Numbers {
    pub account: Option<String>,
    pub ach_routing: Option<String>,
    pub ach_wire_routing: Option<String>,
    pub eft_institution: Option<String>,
    pub eft_branch: Option<String>,
    pub international_bic: Option<String>,
    pub international_iban: Option<String>,
    pub bacs_sort_code: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionOverride {
    pub date_transacted: String,
    pub date_posted: String,
    pub amount: f64,
    pub description: String,
    pub currency: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SecurityOverride {
    pub isin: Option<String>,
    pub cusip: Option<String>,
    pub sedol: Option<String>,
    pub name: Option<String>,
    pub ticker_symbol: Option<String>,
    pub currency: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct HoldingsOverride {
    pub institution_price: f64,
    pub institution_price_as_of: Option<String>,
    pub cost_basis: Option<f64>,
    pub quantity: f64,
    pub currency: String,
    pub security: SecurityOverride,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Investments_TransactionsOverride {
    pub date: String,
    pub name: String,
    pub quantity: f64,
    pub price: f64,
    pub fees: Option<f64>,
    #[serde(rename = "type")]
    pub type_: String,
    pub currency: String,
    pub security: Option<SecurityOverride>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LiabilityOverride {
    #[serde(rename = "type")]
    pub type_: String,
    pub purchase_apr: f64,
    pub cash_apr: f64,
    pub balance_transfer_apr: f64,
    pub special_apr: f64,
    pub last_payment_amount: f64,
    pub minimum_payment_amount: f64,
    pub is_overdue: bool,
    pub origination_date: String,
    pub principal: f64,
    pub nominal_apr: f64,
    pub interest_capitalization_grace_period_months: f64,
    pub repayment_model: StudentLoanRepaymentModel,
    pub expected_payoff_date: String,
    pub guarantor: String,
    pub is_federal: bool,
    pub loan_name: String,
    pub loan_status: StudentLoanStatus,
    pub payment_reference_number: String,
    pub pslf_status: PSLFStatus,
    pub repayment_plan_description: String,
    pub repayment_plan_type: String,
    pub sequence_number: String,
    pub servicer_address: Address,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct StudentLoanRepaymentModel {
    #[serde(rename = "type")]
    pub type_: String,
    pub non_repayment_months: f64,
    pub repayment_months: f64,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InflowModel {
    #[serde(rename = "type")]
    pub type_: String,
    pub income_amount: f64,
    pub payment_day_of_month: f64,
    pub transaction_name: String,
    pub statement_day_of_month: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeOverride {
    pub paystubs: Option<Vec<PaystubOverride>>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaystubOverride {
    pub employer: Option<PaystubOverrideEmployer>,
    pub employee: Option<PaystubOverrideEmployee>,
    pub income_breakdown: Option<Vec<IncomeBreakdown>>,
    pub pay_period_details: Option<PayPeriodDetails>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaystubOverrideEmployer {
    pub name: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaystubOverrideEmployee {
    pub name: Option<String>,
    pub address: Option<PaystubOverrideEmployeeAddress>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaystubOverrideEmployeeAddress {
    pub city: Option<String>,
    pub region: Option<String>,
    pub street: Option<String>,
    pub postal_code: Option<String>,
    pub country: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemId(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct AutomaticallyVerifiedWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub account_id: String,
    pub item_id: ItemId,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct JWTHeader {
    pub id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct VerificationExpiredWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub item_id: ItemId,
    pub account_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct WebhookUpdateAcknowledgedWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub item_id: ItemId,
    pub new_webhook_url: String,
    pub error: Option<PlaidError>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PendingExpirationWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub item_id: ItemId,
    pub consent_expiration_time: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemErrorWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub item_id: ItemId,
    pub error: PlaidError,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemProductReadyWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub item_id: ItemId,
    pub error: Option<PlaidError>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Recaptcha_RequiredError {
    pub error_type: String,
    pub error_code: String,
    pub display_message: String,
    pub http_code: String,
    pub link_user_experience: String,
    pub common_causes: String,
    pub troubleshooting_steps: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransfersEventsUpdateWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InvestmentsDefaultUpdateWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub item_id: ItemId,
    pub error: Option<PlaidError>,
    pub new_investments_transactions: f64,
    pub canceled_investments_transactions: f64,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct HoldingsDefaultUpdateWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub item_id: ItemId,
    pub error: Option<PlaidError>,
    pub new_holdings: f64,
    pub updated_holdings: f64,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LiabilitiesDefaultUpdateWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub item_id: ItemId,
    pub error: PlaidError,
    pub account_ids_with_new_liabilities: Vec<String>,
    pub account_ids_with_updated_liabilities: LiabilitiesAccountIdsWithUpdatedLiabilities,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LiabilitiesAccountIdsWithUpdatedLiabilities {}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetsProductReadyWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub asset_report_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetsErrorWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub error: PlaidError,
    pub asset_report_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Cause {
    pub item_id: ItemId,
    pub error: PlaidError,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Warning {
    pub warning_type: String,
    pub warning_code: String,
    pub cause: Cause,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentAmount {
    pub currency: String,
    pub value: f64,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportUser {
    pub client_user_id: Option<String>,
    pub first_name: Option<String>,
    pub middle_name: Option<String>,
    pub last_name: Option<String>,
    pub ssn: Option<String>,
    pub phone_number: Option<String>,
    pub email: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportId(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportToken(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportRefreshAssetReportToken(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct StandaloneCurrencyCodeList {
    pub iso_currency_code: String,
    pub unofficial_currency_code: UnofficialCurrencyCodeList,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct UnofficialCurrencyCodeList(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct StandaloneAccountType {
    pub depository: DepositoryAccount,
    pub credit: CreditAccount,
    pub loan: LoanAccount,
    pub investment: InvestmentAccountSubtypeStandalone,
    pub other: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositoryAccount(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct CreditAccount(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct LoanAccount(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct InvestmentAccountSubtypeStandalone(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReport {
    pub asset_report_id: AssetReportId,
    pub client_report_id: Option<String>,
    pub date_generated: String,
    pub days_requested: f64,
    pub user: AssetReportUser,
    pub items: Vec<AssetReportItem>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportItem {
    pub item_id: ItemId,
    pub institution_name: String,
    pub institution_id: String,
    pub date_last_updated: String,
    pub accounts: Vec<AccountAssets>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaymentStatusUpdateWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub payment_id: String,
    pub new_payment_status: PaymentInitiationPaymentStatus,
    pub old_payment_status: PaymentInitiationPaymentStatus,
    pub original_reference: Option<String>,
    pub adjusted_reference: Option<String>,
    pub original_start_date: Option<String>,
    pub adjusted_start_date: Option<String>,
    pub timestamp: String,
    pub error: Option<PlaidError>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Holding {
    pub account_id: String,
    pub security_id: String,
    pub institution_price: f64,
    pub institution_price_as_of: Option<String>,
    pub institution_value: f64,
    pub cost_basis: Option<f64>,
    pub quantity: f64,
    pub iso_currency_code: Option<String>,
    pub unofficial_currency_code: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Security {
    pub security_id: String,
    pub isin: Option<String>,
    pub cusip: Option<String>,
    pub sedol: Option<String>,
    pub institution_security_id: Option<String>,
    pub institution_id: Option<String>,
    pub proxy_security_id: Option<String>,
    pub name: Option<String>,
    pub ticker_symbol: Option<String>,
    pub is_cash_equivalent: Option<bool>,
    #[serde(rename = "type")]
    pub type_: Option<String>,
    pub close_price: Option<f64>,
    pub close_price_as_of: Option<String>,
    pub iso_currency_code: Option<String>,
    pub unofficial_currency_code: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InvestmentTransaction {
    pub investment_transaction_id: String,
    pub cancel_transaction_id: Option<String>,
    pub account_id: String,
    pub security_id: Option<String>,
    pub date: String,
    pub name: String,
    pub quantity: f64,
    pub amount: f64,
    pub price: f64,
    pub fees: Option<f64>,
    #[serde(rename = "type")]
    pub type_: String,
    pub subtype: String,
    pub iso_currency_code: Option<String>,
    pub unofficial_currency_code: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct StandaloneInvestmentTransactionType {
    pub buy: StandaloneInvestmentTransactionBuyType,
    pub sell: StandaloneInvestmentTransactionSellType,
    pub cancel: String,
    pub cash: StandaloneInvestmentTransactionCashType,
    pub fee: StandaloneInvestmentTransactionFeeType,
    pub transfer: StandaloneInvestmentTransactionTransferType,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct StandaloneInvestmentTransactionBuyType(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct StandaloneInvestmentTransactionCashType(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct StandaloneInvestmentTransactionFeeType(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct StandaloneInvestmentTransactionSellType(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct StandaloneInvestmentTransactionTransferType(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountSubtypes(pub Vec<AccountSubtype>);
#[derive(Debug, Serialize, Deserialize)]
pub struct UserPermissionRevokedWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub item_id: ItemId,
    pub error: Option<PlaidError>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositSwitchGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub deposit_switch_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositSwitchGetResponse {
    pub deposit_switch_id: String,
    pub target_account_id: Option<String>,
    pub target_item_id: Option<String>,
    pub state: String,
    pub switch_method: Option<String>,
    pub account_has_multiple_allocations: Option<bool>,
    pub is_allocated_remainder: Option<bool>,
    pub percent_allocated: Option<f64>,
    pub amount_allocated: Option<f64>,
    pub employer_name: Option<String>,
    pub employer_id: Option<String>,
    pub institution_name: Option<String>,
    pub institution_id: Option<String>,
    pub date_created: String,
    pub date_completed: Option<String>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositSwitchStateUpdateWebhook {
    pub webhook_type: Option<String>,
    pub webhook_code: Option<String>,
    pub state: Option<String>,
    pub deposit_switch_id: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportAuditCopyGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub audit_copy_token: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub transfer_id: TransferID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub bank_transfer_id: BankTransferID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferGetResponse {
    pub transfer: Transfer,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferGetResponse {
    pub bank_transfer: BankTransfer,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferID(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferSweepID(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferAuthorizationID(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferID(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct Transfer {
    pub id: TransferID,
    pub ach_class: ACHClass,
    pub account_id: String,
    #[serde(rename = "type")]
    pub type_: TransferType,
    pub user: TransferUserInResponse,
    pub amount: TransferAmount,
    pub description: String,
    pub created: String,
    pub status: TransferStatus,
    pub sweep_status: TransferSweepStatus,
    pub network: TransferNetwork,
    pub cancellable: bool,
    pub failure_reason: TransferFailure,
    pub metadata: TransferMetadata,
    pub origination_account_id: String,
    pub guarantee_decision: TransferAuthorizationGuaranteeDecision,
    pub guarantee_decision_rationale: TransferAuthorizationGuaranteeDecisionRationale,
    pub iso_currency_code: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransfer {
    pub id: BankTransferID,
    pub ach_class: ACHClass,
    pub account_id: String,
    #[serde(rename = "type")]
    pub type_: BankTransferType,
    pub user: BankTransferUser,
    pub amount: BankTransferAmount,
    pub iso_currency_code: String,
    pub description: String,
    pub created: String,
    pub status: BankTransferStatus,
    pub network: BankTransferNetwork,
    pub cancellable: bool,
    pub failure_reason: BankTransferFailure,
    pub custom_tag: Option<String>,
    pub metadata: BankTransferMetadata,
    pub origination_account_id: String,
    pub direction: BankTransferDirection,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ACHClass(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferAmount(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferSweepAmount(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferIntentGetFailureReason {
    pub error_type: Option<String>,
    pub error_code: Option<String>,
    pub error_message: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferIntentCreateMode(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferAmount(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferCreateIdempotencyKey(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferIdempotencyKey(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferUserInRequest {
    pub legal_name: String,
    pub phone_number: Option<String>,
    pub email_address: Option<String>,
    pub address: Option<TransferUserAddressInRequest>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferUserInResponse {
    pub legal_name: String,
    pub phone_number: Option<String>,
    pub email_address: Option<String>,
    pub address: TransferUserAddressInResponse,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferUserAddressInRequest {
    pub street: Option<String>,
    pub city: Option<String>,
    pub region: Option<String>,
    pub postal_code: Option<String>,
    pub country: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferUserAddressInResponse {
    pub street: Option<String>,
    pub city: Option<String>,
    pub region: Option<String>,
    pub postal_code: Option<String>,
    pub country: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferUser {
    pub legal_name: String,
    pub email_address: Option<String>,
    pub routing_number: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferAuthorizationDecisionRationale {
    pub code: String,
    pub description: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferAuthorizationGuaranteeDecision(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferAuthorizationGuaranteeDecisionRationale {
    pub code: String,
    pub description: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferAuthorizationProposedTransfer {
    pub ach_class: ACHClass,
    pub account_id: String,
    #[serde(rename = "type")]
    pub type_: TransferType,
    pub user: TransferUserInResponse,
    pub amount: TransferAmount,
    pub network: String,
    pub origination_account_id: String,
    pub iso_currency_code: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferAuthorizationDevice {
    pub ip_address: Option<String>,
    pub user_agent: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferMetadata {}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferMetadata {}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferType(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferType(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferStatus(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferSweepStatus(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferStatus(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferNetwork(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferNetwork(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferFailure {
    pub ach_return_code: Option<String>,
    pub description: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferFailure {
    pub ach_return_code: Option<String>,
    pub description: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferAuthorizationCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: TransferAccessToken,
    pub account_id: String,
    #[serde(rename = "type")]
    pub type_: TransferType,
    pub network: TransferNetwork,
    pub amount: TransferAmount,
    pub ach_class: ACHClass,
    pub user: TransferUserInRequest,
    pub device: Option<TransferAuthorizationDevice>,
    pub origination_account_id: Option<String>,
    pub iso_currency_code: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub idempotency_key: Option<TransferCreateIdempotencyKey>,
    pub access_token: TransferAccessToken,
    pub account_id: String,
    pub authorization_id: String,
    #[serde(rename = "type")]
    pub type_: TransferType,
    pub network: TransferNetwork,
    pub amount: TransferAmount,
    pub description: String,
    pub ach_class: ACHClass,
    pub user: TransferUserInRequest,
    pub metadata: TransferMetadata,
    pub origination_account_id: Option<String>,
    pub iso_currency_code: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub idempotency_key: BankTransferIdempotencyKey,
    pub access_token: BankTransferAccessToken,
    pub account_id: String,
    #[serde(rename = "type")]
    pub type_: BankTransferType,
    pub network: BankTransferNetwork,
    pub amount: BankTransferAmount,
    pub iso_currency_code: String,
    pub description: String,
    pub ach_class: Option<ACHClass>,
    pub user: BankTransferUser,
    pub custom_tag: Option<String>,
    pub metadata: BankTransferMetadata,
    pub origination_account_id: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferAuthorizationCreateResponse {
    pub authorization: TransferAuthorization,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferAuthorization {
    pub id: TransferAuthorizationID,
    pub created: String,
    pub decision: String,
    pub decision_rationale: TransferAuthorizationDecisionRationale,
    pub guarantee_decision: TransferAuthorizationGuaranteeDecision,
    pub guarantee_decision_rationale: TransferAuthorizationGuaranteeDecisionRationale,
    pub proposed_transfer: TransferAuthorizationProposedTransfer,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferCreateResponse {
    pub transfer: Transfer,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferCreateResponse {
    pub bank_transfer: BankTransfer,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferListRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub start_date: Option<String>,
    pub end_date: Option<String>,
    pub count: Option<i64>,
    pub offset: Option<i64>,
    pub origination_account_id: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferListRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub start_date: Option<String>,
    pub end_date: Option<String>,
    pub count: Option<i64>,
    pub offset: Option<i64>,
    pub origination_account_id: Option<String>,
    pub direction: BankTransferDirection,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferListResponse {
    pub transfers: Vec<Transfer>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferListResponse {
    pub bank_transfers: Vec<BankTransfer>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferDirection(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferCancelRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub transfer_id: TransferID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferCancelRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub bank_transfer_id: BankTransferID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferCancelResponse {
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferCancelResponse {
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferEventListRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub start_date: Option<String>,
    pub end_date: Option<String>,
    pub transfer_id: Option<String>,
    pub account_id: Option<String>,
    pub transfer_type: Option<String>,
    pub event_types: Option<Vec<TransferEventType>>,
    pub sweep_id: Option<String>,
    pub count: Option<i64>,
    pub offset: Option<i64>,
    pub origination_account_id: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferEventListRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub start_date: Option<String>,
    pub end_date: Option<String>,
    pub bank_transfer_id: Option<String>,
    pub account_id: Option<String>,
    pub bank_transfer_type: Option<String>,
    pub event_types: Option<Vec<BankTransferEventType>>,
    pub count: Option<i64>,
    pub offset: Option<i64>,
    pub origination_account_id: Option<String>,
    pub direction: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferEventType(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferEventType(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferEvent {
    pub event_id: i64,
    pub timestamp: String,
    pub event_type: TransferEventType,
    pub account_id: String,
    pub transfer_id: TransferID,
    pub origination_account_id: Option<String>,
    pub transfer_type: TransferType,
    pub transfer_amount: TransferAmount,
    pub failure_reason: TransferFailure,
    pub sweep_id: TransferSweepID,
    pub sweep_amount: TransferSweepAmount,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferEvent {
    pub event_id: i64,
    pub timestamp: String,
    pub event_type: BankTransferEventType,
    pub account_id: String,
    pub bank_transfer_id: BankTransferID,
    pub origination_account_id: Option<String>,
    pub bank_transfer_type: BankTransferType,
    pub bank_transfer_amount: String,
    pub bank_transfer_iso_currency_code: String,
    pub failure_reason: BankTransferFailure,
    pub direction: BankTransferDirection,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferEventListResponse {
    pub transfer_events: Vec<TransferEvent>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferEventListResponse {
    pub bank_transfer_events: Vec<BankTransferEvent>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferEventSyncRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub after_id: i64,
    pub count: Option<i64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferEventSyncRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub after_id: i64,
    pub count: Option<i64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferEventSyncResponse {
    pub bank_transfer_events: Vec<BankTransferEvent>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferEventSyncResponse {
    pub transfer_events: Vec<TransferEvent>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferSweepGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub sweep_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferSweepGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub sweep_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferSweepGetResponse {
    pub sweep: BankTransferSweep,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferSweepGetResponse {
    pub sweep: TransferSweep,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferSweepListRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub origination_account_id: Option<String>,
    pub start_time: Option<String>,
    pub end_time: Option<String>,
    pub count: Option<i64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferSweepListRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub start_date: Option<String>,
    pub end_date: Option<String>,
    pub count: Option<i64>,
    pub offset: Option<i64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferSweepListResponse {
    pub sweeps: Vec<TransferSweep>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferSweepListResponse {
    pub sweeps: Vec<BankTransferSweep>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferSweep {
    pub id: String,
    pub created_at: String,
    pub amount: String,
    pub iso_currency_code: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferSweep {
    pub id: String,
    pub created: String,
    pub amount: String,
    pub iso_currency_code: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SimulatedTransferSweep {}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferBalanceGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub origination_account_id: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferBalanceGetResponse {
    pub balance: BankTransferBalance,
    pub origination_account_id: Option<String>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferBalance {
    pub available: String,
    pub transactable: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferMigrateAccountRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub account_number: String,
    pub routing_number: String,
    pub account_type: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankTransferMigrateAccountResponse {
    pub access_token: String,
    pub account_id: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferRepaymentListRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub start_date: Option<String>,
    pub end_date: Option<String>,
    pub count: Option<i64>,
    pub offset: Option<i64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferRepaymentListResponse {
    pub repayments: Vec<TransferRepayment>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferRepayment {
    pub repayment_id: String,
    pub created: String,
    pub amount: String,
    pub iso_currency_code: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferRepaymentReturnListRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub repayment_id: String,
    pub count: Option<i64>,
    pub offset: Option<i64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferRepaymentReturnListResponse {
    pub repayment_returns: Vec<TransferRepaymentReturn>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferRepaymentReturn {
    pub transfer_id: String,
    pub event_id: i64,
    pub amount: String,
    pub iso_currency_code: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferIntentCreateRequest {
    pub client_id: APIClientID,
    pub secret: APISecret,
    pub account_id: Option<String>,
    pub mode: TransferIntentCreateMode,
    pub amount: TransferAmount,
    pub description: String,
    pub ach_class: ACHClass,
    pub origination_account_id: Option<String>,
    pub user: TransferUserInRequest,
    pub metadata: TransferMetadata,
    pub iso_currency_code: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferIntentCreate {
    pub id: String,
    pub created: String,
    pub status: String,
    pub account_id: Option<String>,
    pub origination_account_id: String,
    pub amount: TransferAmount,
    pub mode: TransferIntentCreateMode,
    pub ach_class: ACHClass,
    pub user: TransferUserInResponse,
    pub description: String,
    pub metadata: TransferMetadata,
    pub iso_currency_code: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferIntentCreateResponse {
    pub transfer_intent: TransferIntentCreate,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferIntentGetRequest {
    pub client_id: APIClientID,
    pub secret: APISecret,
    pub transfer_intent_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferIntentGet {
    pub id: String,
    pub created: String,
    pub status: String,
    pub transfer_id: Option<String>,
    pub failure_reason: TransferIntentGetFailureReason,
    pub authorization_decision: Option<String>,
    pub authorization_decision_rationale: TransferAuthorizationDecisionRationale,
    pub account_id: Option<String>,
    pub origination_account_id: String,
    pub amount: TransferAmount,
    pub mode: TransferIntentCreateMode,
    pub ach_class: ACHClass,
    pub user: TransferUserInResponse,
    pub description: String,
    pub metadata: TransferMetadata,
    pub iso_currency_code: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransferIntentGetResponse {
    pub transfer_intent: TransferIntentGet,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxBankTransferSimulateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub bank_transfer_id: BankTransferID,
    pub event_type: String,
    pub failure_reason: BankTransferFailure,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxTransferSimulateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub transfer_id: TransferID,
    pub event_type: String,
    pub failure_reason: TransferFailure,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxTransferSweepSimulateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxBankTransferSimulateResponse {
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxTransferSimulateResponse {
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxTransferSweepSimulateResponse {
    pub sweep: Option<SimulatedTransferSweep>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxTransferRepaymentSimulateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxTransferRepaymentSimulateResponse {
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountFiltersResponse {
    pub depository: Option<DepositoryFilter>,
    pub credit: Option<CreditFilter>,
    pub loan: Option<LoanFilter>,
    pub investment: Option<InvestmentFilter>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InstitutionsSearchAccountFilter {
    pub loan: Option<Vec<AccountSubtype>>,
    pub depository: Option<Vec<AccountSubtype>>,
    pub credit: Option<Vec<AccountSubtype>>,
    pub investment: Option<Vec<AccountSubtype>>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountIdentity(pub serde_json::Value);
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountAssets(pub serde_json::Value);
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositoryFilter {
    pub account_subtypes: DepositoryAccountSubtypes,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct CreditFilter {
    pub account_subtypes: CreditAccountSubtypes,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct LoanFilter {
    pub account_subtypes: LoanAccountSubtypes,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct InvestmentFilter {
    pub account_subtypes: InvestmentAccountSubtypes,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositoryAccountSubtypes(pub Vec<DepositoryAccountSubtype>);
#[derive(Debug, Serialize, Deserialize)]
pub struct CreditAccountSubtypes(pub Vec<CreditAccountSubtype>);
#[derive(Debug, Serialize, Deserialize)]
pub struct LoanAccountSubtypes(pub Vec<LoanAccountSubtype>);
#[derive(Debug, Serialize, Deserialize)]
pub struct InvestmentAccountSubtypes(pub Vec<InvestmentAccountSubtype>);
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositoryAccountSubtype(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct CreditAccountSubtype(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct LoanAccountSubtype(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct InvestmentAccountSubtype(pub serde_json::Value);
#[derive(Debug, Serialize, Deserialize)]
pub struct EmployersSearchRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub query: String,
    pub products: Vec<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct EmployersSearchResponse {
    pub employers: Vec<Employer>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Employer {
    pub employer_id: String,
    pub name: String,
    pub address: AddressDataNullable,
    pub confidence_score: f64,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub webhook: String,
    pub precheck_id: Option<String>,
    pub options: Option<IncomeVerificationCreateRequestOptions>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationCreateRequestOptions {
    pub access_tokens: Option<Vec<AccessToken>>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationCreateResponse {
    pub income_verification_id: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationPrecheckRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub user: IncomeVerificationPrecheckUser,
    pub employer: IncomeVerificationPrecheckEmployer,
    pub transactions_access_token: Option<serde_json::Value>,
    pub transactions_access_tokens: Option<Vec<AccessToken>>,
    pub us_military_info: IncomeVerificationPrecheckMilitaryInfo,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationPrecheckEmployer {
    pub name: Option<String>,
    pub address: IncomeVerificationPrecheckEmployerAddress,
    pub tax_id: Option<String>,
    pub url: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationPrecheckEmployerAddress {}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationPrecheckEmployerAddressData {
    pub city: Option<String>,
    pub region: Option<String>,
    pub street: Option<String>,
    pub postal_code: Option<String>,
    pub country: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationPrecheckMilitaryInfo {
    pub is_active_duty: Option<bool>,
    pub branch: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationPrecheckUser {
    pub first_name: Option<String>,
    pub last_name: Option<String>,
    pub email_address: Option<String>,
    pub home_address: SignalAddressData,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationPrecheckResponse {
    pub precheck_id: String,
    pub request_id: RequestID,
    pub confidence: IncomeVerificationPrecheckConfidence,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationPrecheckConfidence(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct LinkTokenCreateRequestIncomeVerification {
    pub income_verification_id: Option<String>,
    pub asset_report_id: Option<String>,
    pub precheck_id: Option<String>,
    pub access_tokens: Option<Vec<AccessToken>>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationStatusWebhook {
    pub webhook_type: String,
    pub webhook_code: String,
    pub income_verification_id: String,
    pub item_id: String,
    pub verification_status: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationSummaryGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub income_verification_id: Option<String>,
    pub access_token: AccessTokenNullable,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationSummaryGetResponse {
    pub income_summaries: Vec<IncomeSummary>,
    pub error: Option<PlaidError>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationRefreshRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub income_verification_id: Option<String>,
    pub access_token: AccessTokenNullable,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationRefreshResponse {
    pub request_id: RequestID,
    pub verification_refresh_status: VerificationRefreshStatus,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeSummary {
    pub employer_name: EmployerIncomeSummaryFieldString,
    pub employee_name: EmployeeIncomeSummaryFieldString,
    pub ytd_gross_income: YTDGrossIncomeSummaryFieldNumber,
    pub ytd_net_income: YTDNetIncomeSummaryFieldNumber,
    pub pay_frequency: PayFrequency,
    pub projected_wage: ProjectedIncomeSummaryFieldNumber,
    pub verified_transaction: TransactionData,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionData {
    pub description: String,
    pub amount: f64,
    pub date: String,
    pub account_id: String,
    pub transaction_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeSummaryFieldString {
    pub value: String,
    pub verification_status: VerificationStatus,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct EmployerIncomeSummaryFieldString(pub serde_json::Value);
#[derive(Debug, Serialize, Deserialize)]
pub struct EmployeeIncomeSummaryFieldString(pub serde_json::Value);
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeSummaryFieldNumber {
    pub value: f64,
    pub verification_status: VerificationStatus,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct YTDGrossIncomeSummaryFieldNumber(pub serde_json::Value);
#[derive(Debug, Serialize, Deserialize)]
pub struct YTDNetIncomeSummaryFieldNumber(pub serde_json::Value);
#[derive(Debug, Serialize, Deserialize)]
pub struct ProjectedIncomeSummaryFieldNumber(pub serde_json::Value);
#[derive(Debug, Serialize, Deserialize)]
pub struct PayFrequency {
    pub value: PayFrequencyValue,
    pub verification_status: VerificationStatus,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PayFrequencyValue(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct VerificationStatus(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct VerificationRefreshStatus(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationPaystubGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub income_verification_id: Option<String>,
    pub access_token: AccessTokenNullable,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationPaystubGetResponse {
    pub paystub: Paystub,
    pub error: Option<PlaidError>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationPaystubsGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub income_verification_id: Option<String>,
    pub access_token: AccessTokenNullable,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationPaystubsGetResponse {
    pub document_metadata: Option<Vec<DocumentMetadata>>,
    pub paystubs: Vec<Paystub>,
    pub error: Option<PlaidError>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DocumentMetadata {
    pub name: Option<String>,
    pub status: Option<String>,
    pub doc_id: Option<String>,
    pub doc_type: Option<DocType>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DocType(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct Paystub {
    pub deductions: Deductions,
    pub doc_id: String,
    pub earnings: Earnings,
    pub employee: Employee,
    pub employer: PaystubEmployer,
    pub employment_details: Option<EmploymentDetails>,
    pub net_pay: NetPay,
    pub pay_period_details: PayPeriodDetails,
    pub paystub_details: Option<PaystubDetails>,
    pub income_breakdown: Option<Vec<IncomeBreakdown>>,
    pub ytd_earnings: Option<PaystubYTDDetails>,
    pub verification: PaystubVerification,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Deductions {
    pub subtotals: Option<Vec<Total>>,
    pub breakdown: Vec<DeductionsBreakdown>,
    pub totals: Option<Vec<Total>>,
    pub total: DeductionsTotal,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DeductionsBreakdown {
    pub current_amount: Option<f64>,
    pub description: Option<String>,
    pub iso_currency_code: Option<String>,
    pub unofficial_currency_code: Option<String>,
    pub ytd_amount: Option<f64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DeductionsTotal {
    pub current_amount: Option<f64>,
    pub iso_currency_code: Option<String>,
    pub unofficial_currency_code: Option<String>,
    pub ytd_amount: Option<f64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Total {
    pub canonical_description: TotalCanonicalDescription,
    pub description: Option<String>,
    pub current_pay: Option<Pay>,
    pub ytd_pay: Option<Pay>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TotalCanonicalDescription(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct Pay {
    pub amount: Option<f64>,
    pub currency: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Earnings {
    pub subtotals: Option<Vec<EarningsTotal>>,
    pub totals: Option<Vec<EarningsTotal>>,
    pub breakdown: Option<Vec<EarningsBreakdown>>,
    pub total: Option<EarningsTotal>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct EarningsBreakdown {
    pub canonical_description: EarningsBreakdownCanonicalDescription,
    pub current_amount: Option<f64>,
    pub description: Option<String>,
    pub hours: Option<f64>,
    pub iso_currency_code: Option<String>,
    pub rate: Option<f64>,
    pub unofficial_currency_code: Option<String>,
    pub ytd_amount: Option<f64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct EarningsBreakdownCanonicalDescription(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct EarningsTotal {
    pub current_amount: Option<f64>,
    pub current_pay: Option<Pay>,
    pub ytd_pay: Option<Pay>,
    pub hours: Option<f64>,
    pub iso_currency_code: Option<String>,
    pub unofficial_currency_code: Option<String>,
    pub ytd_amount: Option<f64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct EmploymentDetails {
    pub annual_salary: Option<Pay>,
    pub hire_date: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct NetPay {
    pub current_amount: Option<f64>,
    pub description: Option<String>,
    pub iso_currency_code: Option<String>,
    pub unofficial_currency_code: Option<String>,
    pub ytd_amount: Option<f64>,
    pub total: Option<Total>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaystubDetails {
    pub pay_period_start_date: Option<String>,
    pub pay_period_end_date: Option<String>,
    pub pay_date: Option<String>,
    pub paystub_provider: Option<String>,
    pub pay_frequency: PaystubPayFrequency,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaystubPayFrequency(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeBreakdown {
    #[serde(rename = "type")]
    pub type_: IncomeBreakdownType,
    pub rate: Option<f64>,
    pub hours: Option<f64>,
    pub total: Option<f64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeBreakdownType(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct Employee {
    pub address: PaystubAddress,
    pub name: Option<String>,
    pub marital_status: Option<String>,
    pub taxpayer_id: Option<TaxpayerID>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TaxpayerID {
    pub id_type: Option<String>,
    pub id_mask: Option<String>,
    pub last_4_digits: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaystubEmployer {
    pub address: Option<PaystubAddress>,
    pub name: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaystubAddress {
    pub city: Option<String>,
    pub country: Option<String>,
    pub postal_code: Option<String>,
    pub region: Option<String>,
    pub street: Option<String>,
    pub line1: Option<String>,
    pub line2: Option<String>,
    pub state_code: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PayPeriodDetails {
    pub check_amount: Option<f64>,
    pub distribution_breakdown: Option<Vec<DistributionBreakdown>>,
    pub end_date: Option<String>,
    pub gross_earnings: Option<f64>,
    pub pay_date: Option<String>,
    pub pay_frequency: Option<String>,
    pub pay_day: Option<String>,
    pub start_date: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DistributionBreakdown {
    pub account_name: Option<String>,
    pub bank_name: Option<String>,
    pub current_amount: Option<f64>,
    pub iso_currency_code: Option<String>,
    pub mask: Option<String>,
    #[serde(rename = "type")]
    pub type_: Option<String>,
    pub unofficial_currency_code: Option<String>,
    pub current_pay: Option<Pay>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaystubDeduction {
    #[serde(rename = "type")]
    pub type_: Option<String>,
    pub is_pretax: Option<bool>,
    pub total: Option<f64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaystubYTDDetails {
    pub gross_earnings: Option<f64>,
    pub net_earnings: Option<f64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaystubVerification {
    pub verification_status: PaystubVerificationStatus,
    pub verification_attributes: Vec<VerificationAttribute>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PaystubVerificationStatus(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct VerificationAttribute {
    #[serde(rename = "type")]
    pub type_: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationDocumentsDownloadRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub income_verification_id: Option<String>,
    pub access_token: AccessTokenNullable,
    pub document_id: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationTaxformsGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub income_verification_id: Option<String>,
    pub access_token: AccessTokenNullable,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationTaxformsGetResponse {
    pub request_id: Option<RequestID>,
    pub document_metadata: Vec<DocumentMetadata>,
    pub taxforms: Vec<Taxform>,
    pub error: Option<PlaidError>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct Taxform {
    pub doc_id: Option<String>,
    pub document_type: String,
    pub w2: Option<W2>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct W2 {
    pub employer: Option<PaystubEmployer>,
    pub employee: Option<Employee>,
    pub tax_year: Option<String>,
    pub employer_id_number: Option<String>,
    pub wages_tips_other_comp: Option<String>,
    pub federal_income_tax_withheld: Option<String>,
    pub social_security_wages: Option<String>,
    pub social_security_tax_withheld: Option<String>,
    pub medicare_wages_and_tips: Option<String>,
    pub medicare_tax_withheld: Option<String>,
    pub social_security_tips: Option<String>,
    pub allocated_tips: Option<String>,
    pub box_9: Option<String>,
    pub dependent_care_benefits: Option<String>,
    pub nonqualified_plans: Option<String>,
    pub box_12: Option<Vec<W2Box12>>,
    pub statutory_employee: Option<String>,
    pub retirement_plan: Option<String>,
    pub third_party_sick_pay: Option<String>,
    pub other: Option<String>,
    pub state_and_local_wages: Option<Vec<W2StateAndLocalWages>>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct W2Box12 {
    pub code: Option<String>,
    pub amount: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct W2StateAndLocalWages {
    pub state: Option<String>,
    pub employer_state_id_number: Option<String>,
    pub state_wages_tips: Option<String>,
    pub state_income_tax: Option<String>,
    pub local_wages_tips: Option<String>,
    pub local_income_tax: Option<String>,
    pub locality_name: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncomeVerificationWebhookStatus {
    pub id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct EmploymentVerificationGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct EmploymentVerificationGetResponse {
    pub employments: Vec<EmploymentVerification>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct EmploymentVerification {
    pub status: EmploymentVerificationStatus,
    pub start_date: Option<String>,
    pub end_date: Option<String>,
    pub employer: Option<EmployerVerification>,
    pub title: Option<String>,
    pub platform_ids: Option<PlatformIds>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct EmploymentVerificationStatus(pub Option<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct EmployerVerification {
    pub name: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PlatformIds {
    pub employee_id: Option<String>,
    pub payroll_id: Option<String>,
    pub position_id: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetReportTransaction(pub serde_json::Value);
#[derive(Debug, Serialize, Deserialize)]
pub struct HealthIncident {
    pub start_date: String,
    pub end_date: Option<String>,
    pub title: String,
    pub incident_updates: Vec<IncidentUpdate>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct IncidentUpdate {
    pub description: Option<String>,
    pub status: Option<String>,
    pub updated_date: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositSwitchAltCreateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub target_account: DepositSwitchTargetAccount,
    pub target_user: DepositSwitchTargetUser,
    pub options: Option<DepositSwitchCreateRequestOptions>,
    pub country_code: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositSwitchAltCreateResponse {
    pub deposit_switch_id: String,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositSwitchTargetAccount {
    pub account_number: String,
    pub routing_number: String,
    pub account_name: String,
    pub account_subtype: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositSwitchTargetUser {
    pub given_name: String,
    pub family_name: String,
    pub phone: String,
    pub email: String,
    pub address: Option<DepositSwitchAddressData>,
    pub tax_payer_id: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositSwitchAddressData {
    pub city: String,
    pub region: String,
    pub street: String,
    pub postal_code: String,
    pub country: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxBankTransferFireWebhookRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub webhook: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxBankTransferFireWebhookResponse {
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ApplicationID(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct Application {
    pub application_id: ApplicationID,
    pub name: String,
    pub created_at: Option<String>,
    pub join_date: String,
    pub logo_url: Option<String>,
    pub application_url: Option<String>,
    pub reason_for_access: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ApplicationGetRequest {
    pub client_id: APIClientID,
    pub secret: APISecret,
    pub application_id: ApplicationID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ApplicationGetResponse {
    pub request_id: RequestID,
    pub application: Application,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ProductAccess {
    pub statements: Option<bool>,
    pub identity: Option<bool>,
    pub auth: Option<bool>,
    pub transactions: Option<bool>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountAccess {
    pub unique_id: String,
    pub authorized: Option<bool>,
    pub account_product_access: AccountProductAccessNullable,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountProductAccessNullable(pub Option<serde_json::Value>);
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountProductAccess {
    pub account_data: Option<bool>,
    pub statements: Option<bool>,
    pub tax_documents: Option<bool>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ScopesNullable(pub Option<serde_json::Value>);
#[derive(Debug, Serialize, Deserialize)]
pub struct Scopes {
    pub product_access: Option<ProductAccess>,
    pub accounts: Option<Vec<AccountAccess>>,
    pub new_accounts: Option<bool>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct RequestedScopes {
    pub account_filters: Option<AccountFilter>,
    pub account_selection_cardinality: AccountSelectionCardinality,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ScopesState(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct ScopesContext(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemApplicationScopesUpdateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
    pub application_id: ApplicationID,
    pub scopes: Scopes,
    pub state: Option<ScopesState>,
    pub context: ScopesContext,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemApplicationScopesUpdateResponse {
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemApplicationListRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessTokenNullable,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemApplicationListResponse {
    pub request_id: Option<RequestID>,
    pub applications: Vec<ConnectedApplication>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ConnectedApplication {
    pub application_id: ApplicationID,
    pub name: String,
    pub logo: Option<String>,
    pub logo_url: Option<String>,
    pub application_url: Option<String>,
    pub reason_for_access: Option<String>,
    pub created_at: String,
    pub join_date: String,
    pub product_data_types: Vec<String>,
    pub scopes: ScopesNullable,
    pub requested_scopes: Option<RequestedScopes>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountSelectionCardinality(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountFilter {
    pub depository: Option<AccountFilterSubtypes>,
    pub credit: Option<AccountFilterSubtypes>,
    pub loan: Option<AccountFilterSubtypes>,
    pub investment: Option<AccountFilterSubtypes>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct AccountFilterSubtypes(pub Vec<String>);
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxIncomeFireWebhookRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub income_verification_id: String,
    pub item_id: String,
    pub webhook: String,
    pub verification_status: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxIncomeFireWebhookResponse {
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct ItemApplicationListUserAuth {
    pub user_id: Option<String>,
    pub fi_username_hash: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SignalEvaluateRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub access_token: AccessToken,
    pub account_id: String,
    pub client_transaction_id: String,
    pub amount: f64,
    pub user_present: Option<bool>,
    pub client_user_id: Option<String>,
    pub user: Option<SignalUser>,
    pub device: Option<SignalDevice>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SignalUser {
    pub name: SignalPersonName,
    pub phone_number: Option<String>,
    pub email_address: Option<String>,
    pub address: SignalAddressData,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SignalPersonName {
    pub prefix: Option<String>,
    pub given_name: Option<String>,
    pub middle_name: Option<String>,
    pub family_name: Option<String>,
    pub suffix: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SignalAddressData {
    pub city: Option<String>,
    pub region: Option<String>,
    pub street: Option<String>,
    pub postal_code: Option<String>,
    pub country: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SignalDevice {
    pub ip_address: Option<String>,
    pub user_agent: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SignalEvaluateResponse {
    pub request_id: RequestID,
    pub scores: SignalScores,
    pub core_attributes: Option<SignalEvaluateCoreAttributes>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SignalScores {
    pub customer_initiated_return_risk: Option<CustomerInitiatedReturnRisk>,
    pub bank_initiated_return_risk: Option<BankInitiatedReturnRisk>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SignalScore(pub i64);
#[derive(Debug, Serialize, Deserialize)]
pub struct CustomerInitiatedRiskTier(pub i64);
#[derive(Debug, Serialize, Deserialize)]
pub struct CustomerInitiatedReturnRisk {
    pub score: SignalScore,
    pub risk_tier: CustomerInitiatedRiskTier,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct BankInitiatedRiskTier(pub i64);
#[derive(Debug, Serialize, Deserialize)]
pub struct BankInitiatedReturnRisk {
    pub score: SignalScore,
    pub risk_tier: BankInitiatedRiskTier,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SignalEvaluateCoreAttributes {
    pub unauthorized_transactions_count_7d: Option<i64>,
    pub unauthorized_transactions_count_30d: Option<i64>,
    pub unauthorized_transactions_count_60d: Option<i64>,
    pub unauthorized_transactions_count_90d: Option<i64>,
    pub nsf_overdraft_transactions_count_7d: Option<i64>,
    pub nsf_overdraft_transactions_count_30d: Option<i64>,
    pub nsf_overdraft_transactions_count_60d: Option<i64>,
    pub nsf_overdraft_transactions_count_90d: Option<i64>,
    pub days_since_first_plaid_connection: Option<i64>,
    pub plaid_connections_count_7d: Option<i64>,
    pub plaid_connections_count_30d: Option<i64>,
    pub total_plaid_connections_count: Option<i64>,
    pub is_savings_or_money_market_account: Option<bool>,
    pub total_credit_transactions_amount_10d: Option<f64>,
    pub total_debit_transactions_amount_10d: Option<f64>,
    pub p50_credit_transactions_amount_28d: Option<f64>,
    pub p50_debit_transactions_amount_28d: Option<f64>,
    pub p95_credit_transactions_amount_28d: Option<f64>,
    pub p95_debit_transactions_amount_28d: Option<f64>,
    pub days_with_negative_balance_count_90d: Option<i64>,
    pub p90_eod_balance_30d: Option<f64>,
    pub p90_eod_balance_60d: Option<f64>,
    pub p90_eod_balance_90d: Option<f64>,
    pub p10_eod_balance_30d: Option<f64>,
    pub p10_eod_balance_60d: Option<f64>,
    pub p10_eod_balance_90d: Option<f64>,
    pub available_balance: Option<f64>,
    pub current_balance: Option<f64>,
    pub balance_last_updated: Option<String>,
    pub phone_change_count_28d: Option<i64>,
    pub phone_change_count_90d: Option<i64>,
    pub email_change_count_28d: Option<i64>,
    pub email_change_count_90d: Option<i64>,
    pub address_change_count_28d: Option<i64>,
    pub address_change_count_90d: Option<i64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SignalDecisionReportRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub client_transaction_id: String,
    pub initiated: bool,
    pub days_funds_on_hold: Option<i64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SignalDecisionReportResponse {
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SignalReturnReportRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub client_transaction_id: String,
    pub return_code: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SignalReturnReportResponse {
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxOauthSelectAccountsRequest {
    pub oauth_state_id: String,
    pub accounts: Vec<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SandboxOauthSelectAccountsResponse {}
#[derive(Debug, Serialize, Deserialize)]
pub struct NewAccountsAvailableWebhook {
    pub webhook_type: Option<String>,
    pub webhook_code: Option<String>,
    pub item_id: Option<ItemId>,
    pub error: Option<PlaidError>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct WalletGetRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub wallet_id: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct WalletGetResponse {
    pub wallet_id: String,
    pub balance: WalletBalance,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct WalletBalance {
    pub iso_currency_code: String,
    pub current: f64,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct WalletTransactionExecuteRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub idempotency_key: WalletTransactionIdempotencyKey,
    pub wallet_id: String,
    pub counterparty: WalletTransactionCounterparty,
    pub amount: WalletTransactionAmount,
    pub reference: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct WalletTransactionIdempotencyKey(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct WalletTransactionCounterparty {
    pub name: String,
    pub numbers: WalletTransactionCounterpartyNumbers,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct WalletTransactionCounterpartyNumbers {
    pub bacs: WalletTransactionCounterpartyBACS,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct WalletTransactionCounterpartyBACS(pub serde_json::Value);
#[derive(Debug, Serialize, Deserialize)]
pub struct WalletTransactionAmount {
    pub iso_currency_code: String,
    pub value: f64,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct WalletTransactionExecuteResponse {
    pub transaction_id: String,
    pub status: WalletTransactionStatus,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct WalletTransactionStatus(pub String);
#[derive(Debug, Serialize, Deserialize)]
pub struct WalletTransactionsListRequest {
    pub client_id: Option<APIClientID>,
    pub secret: Option<APISecret>,
    pub wallet_id: String,
    pub cursor: Option<String>,
    pub count: Option<i64>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct WalletTransactionsListResponse {
    pub transactions: Vec<WalletTransaction>,
    pub next_cursor: Option<String>,
    pub request_id: RequestID,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct WalletTransaction {
    pub transaction_id: String,
    pub reference: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub amount: WalletTransactionAmount,
    pub counterparty: WalletTransactionCounterparty,
    pub status: WalletTransactionStatus,
    pub created_at: String,
}
